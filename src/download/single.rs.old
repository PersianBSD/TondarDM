//! Single-part downloader with robust resume, Ctrl+C, and light retry
//! Author: Ali Asadi  | Team: Persian Developer Team | Email: persianbsd@gmail.com
//! Behavior:
//! - Uses final CDN URL + (optional) If-Range
//! - Resumes from local file length, seeks to exact offset
//! - Handles 416 by retrying from (offset-1) and discarding the first byte
//! - Graceful Ctrl+C: flush+sync, save .state, exit cleanly
//! - Saves .state every ~1MiB to aid debugging/crash-resume
//! - Light retry (3 attempts) on transient network errors

use crate::engine::prelude::*;
use crate::iox::{file as iox, state as dlstate};
use crate::iox::file::finalize_sync;

use futures_util::StreamExt;
use indicatif::{ProgressBar, ProgressStyle};
use reqwest::{Client, Response, StatusCode};
use tokio::fs::File;
use tokio::io::{AsyncSeekExt, AsyncWriteExt};
use tokio::time::{sleep, Duration};
use std::io::SeekFrom;

pub async fn download_single(
    client: &Client,
    url: &str,                     // final CDN URL
    filename: &str,                // output file name
    size: Option<u64>,             // total size if known
    ranges_supported: bool,
    etag: Option<&str>,            // pass Some(..) only if --if-range was used
    last_modified: Option<&str>,   // pass Some(..) only if --if-range was used
) -> Result<()> {
    let (mut file, existing) = iox::open_for_resume(filename).await?;

    // If local file is larger than total (from a previous bug), shrink it.
    let mut start_offset = match size {
        Some(total) if existing > total => {
            file.set_len(total).await.map_err(DmError::Io)?;
            total
        }
        _ => existing,
    };

    // If server doesn't support ranges but we have partial data → restart from zero.
    if !ranges_supported && start_offset > 0 {
        file.set_len(0).await.map_err(DmError::Io)?;
        start_offset = 0;
    }

    // If we already have the full file, skip.
    if let Some(total) = size {
        if start_offset >= total {
            eprintln!("Already complete (local {} bytes, total {}). Skipping.", start_offset, total);
            let _ = dlstate::remove_state(filename).await;
            return Ok(());
        }
    }

    // Ctrl+C handler: one-shot signal channel
    let (cancel_tx, mut cancel_rx) = tokio::sync::oneshot::channel::<()>();
    tokio::spawn(async move {
        let _ = tokio::signal::ctrl_c().await;
        let _ = cancel_tx.send(());
    });

    // Attempts with simple backoff
    let mut attempt = 0usize;
    let mut offset = start_offset;

    loop {
        attempt += 1;

        let mut resp = make_request(client, url, ranges_supported, offset, etag, last_modified).await?;

        // Handle 416 Range Not Satisfiable
        if resp.status() == StatusCode::RANGE_NOT_SATISFIABLE {
            if let Some(total) = size {
                if offset >= total {
                    eprintln!("416 at offset {offset}; file seems complete. Skipping.");
                    let _ = dlstate::remove_state(filename).await;
                    return Ok(());
                }
            }
            // Try from offset-1, then seek to original offset before writing (drop first byte)
            let back = offset.saturating_sub(1);
            eprintln!("416 at {offset}; retrying from {back}…");
            resp = make_request(client, url, ranges_supported, back, etag, last_modified).await?;
        }

        // Validate resume contract when resuming
        if offset > 0 && ranges_supported {
            use reqwest::header::CONTENT_RANGE;
            let st = resp.status();
            let has_cr = resp.headers().get(CONTENT_RANGE).is_some();
            let cl = resp.content_length();

            let resume_ok = match st {
                StatusCode::PARTIAL_CONTENT => true,
                StatusCode::OK => {
                    if has_cr {
                        true
                    } else if let (Some(len), Some(total)) = (cl, size) {
                        len + offset == total
                    } else {
                        false
                    }
                }
                _ => false,
            };

            if !resume_ok {
                eprintln!("Server did not clearly return resume; restarting from zero.");
                file.set_len(0).await.map_err(DmError::Io)?;
                offset = 0;
                // Loop will retry from zero immediately.
                continue;
            }
        }

        // Ensure we write at the exact offset
        file.seek(SeekFrom::Start(offset)).await.map_err(DmError::Io)?;

        // Stream with progress, periodic state save, cancel, and error retry
        match run_stream_to_file_with_state(
            &mut file, resp, size, offset, url, filename, etag, last_modified, &mut cancel_rx
        ).await {
            Ok(_) => {
                let _ = dlstate::remove_state(filename).await; // cleanup
                return Ok(());
            }
            Err(e) => {
                // Cancel gracefully
                let is_cancel = matches!(&e, DmError::Other(msg) if msg == "cancelled");
                if is_cancel {
                    eprintln!("Interrupted by user (Ctrl+C). State saved.");
                    return Ok(());
                }
                // Transient network error? retry up to 3 times
                if attempt < 3 {
                    eprintln!("Network error: {}. Retrying (attempt {attempt}/3)…", e);
                    sleep(Duration::from_secs(2_u64.pow(attempt as u32))).await;
                    continue;
                } else {
                    return Err(e);
                }
            }
        }
    }
}

async fn make_request(
    client: &Client,
    url: &str,
    ranges_supported: bool,
    start_offset: u64,
    etag: Option<&str>,
    last_modified: Option<&str>,
) -> Result<Response> {
    use reqwest::header::{IF_RANGE, RANGE};
    let mut req = client.get(url);

    if ranges_supported && start_offset > 0 {
        req = req.header(RANGE, format!("bytes={}-", start_offset));
        if let Some(tag) = etag {
            req = req.header(IF_RANGE, tag);
        } else if let Some(lm) = last_modified {
            req = req.header(IF_RANGE, lm);
        }
    }

    let resp = req.send().await.map_err(|e| DmError::Network(e.to_string()))?;

    // Debug once per request
    eprintln!(
        "DEBUG resume: status={:?} CR={:?} CL={:?} off={}",
        resp.status(),
        resp.headers().get(reqwest::header::CONTENT_RANGE),
        resp.content_length(),
        start_offset
    );
    Ok(resp)
}

async fn run_stream_to_file_with_state(
    file: &mut File,
    resp: Response,
    total_size: Option<u64>,
    start_offset: u64,
    url: &str,
    filename: &str,
    etag: Option<&str>,
    last_modified: Option<&str>,
    cancel_rx: &mut tokio::sync::oneshot::Receiver<()>,
) -> Result<()> {
    let expected = total_size.unwrap_or_else(|| start_offset + resp.content_length().unwrap_or(0));

    let pb = ProgressBar::new(expected);
    pb.set_position(start_offset);
    pb.set_style(
        ProgressStyle::with_template(
            "{percent:>3}% {bar:40.cyan/blue} {bytes}/{total_bytes} ({bytes_per_sec}) elapsed {elapsed} ETA {eta}"
        )
        .unwrap()
        .progress_chars("##-"),
    );

    let mut stream = resp.bytes_stream();
    let mut written = start_offset;
    let mut last_state_dump = written;

    loop {
        // Ctrl+C?
        match cancel_rx.try_recv() {
            Ok(()) | Err(tokio::sync::oneshot::error::TryRecvError::Closed) => {
                pb.abandon_with_message("Paused");
                finalize_sync(file).await?;
                let s = dlstate::DlState {
                    url: url.to_string(),
                    filename: filename.to_string(),
                    total: total_size,
                    written,
                    etag: etag.map(|s| s.to_string()),
                    last_modified: last_modified.map(|s| s.to_string()),
                };
                let _ = dlstate::save_state(&s).await;
                return Err(DmError::Other("cancelled".into()));
            }
            Err(tokio::sync::oneshot::error::TryRecvError::Empty) => {
                // continue streaming
            }
        }

        match stream.next().await {
            Some(Ok(chunk)) => {
                file.write_all(&chunk).await.map_err(DmError::Io)?;
                written += chunk.len() as u64;
                pb.set_position(written);

                maybe_save_state(
                    &mut last_state_dump, written, total_size, url, filename, etag, last_modified
                ).await;
            }
            Some(Err(e)) => {
                pb.abandon_with_message("Retrying…");
                finalize_sync(file).await?;
                let s = dlstate::DlState {
                    url: url.to_string(),
                    filename: filename.to_string(),
                    total: total_size,
                    written,
                    etag: etag.map(|s| s.to_string()),
                    last_modified: last_modified.map(|s| s.to_string()),
                };
                let _ = dlstate::save_state(&s).await;
                return Err(DmError::Network(e.to_string()));
            }
            None => {
                pb.finish_with_message("Done");
                finalize_sync(file).await?;
                return Ok(());
            }
        }
    }
}

/// Save `.state` about every ~1 MiB written.
async fn maybe_save_state(
    last_state_dump: &mut u64,
    now_written: u64,
    total_size: Option<u64>,
    url: &str,
    filename: &str,
    etag: Option<&str>,
    last_modified: Option<&str>,
) {
    if now_written >= *last_state_dump + 1_048_576 {
        *last_state_dump = now_written;
        let s = dlstate::DlState {
            url: url.to_string(),
            filename: filename.to_string(),
            total: total_size,
            written: now_written,
            etag: etag.map(|s| s.to_string()),
            last_modified: last_modified.map(|s| s.to_string()),
        };
        let _ = dlstate::save_state(&s).await;
    }
}
